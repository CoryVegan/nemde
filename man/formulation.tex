\documentclass{article}

\setlength{\parindent}{0pt}
\setlength{\parskip}{8pt}

\usepackage{geometry,mathtools,graphicx,pdfpages,titlesec,listings,color,xcolor,amsmath,bm}
\DeclareMathOperator*{\minimise}{minimise}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\geometry{
	a4paper,
	total={170mm,257mm},
	left=25mm,
	top=25mm,
	right=25mm,
	bottom=25mm
}

\title{Approximate NEMDE Formulation}
\author{Aleksis Xenophon}
\allowdisplaybreaks[1]

\graphicspath{{./../src/output/figures}}

\begin{document}
\maketitle

\section{Overview}
Australia's National Electricity Market (NEM) is dispatched via the National Electricity Market Dispatch Engine (NEMDE). The precise formulation of the NEMDE is not made publicly available, however the inputs to the model are. Using these input files along with publicly available information it is possible to infer the NEMDE's structure and construct an approximate representation of the algorithm. As the output of the NEMDE are also made available it is possible to assess the validity of these inferences by comparing output from the inferred model with observed output from the NEMDE. The following sections outline an approximate formulation of the NEMDE.

\section{Notation}

\section{Model}

\subsection{Parameters}

\subsection{Expressions}
\subsubsection{Units}
Unit bid cost:
\begin{equation}
	UnitCost = \sum\limits_{(i,j,k) \in B} K_{ij} p_{ijk} q_{ijk}
\end{equation}

where:

$K_{ij}=
\begin{cases}
	-1 &\textrm{ if $j=$LDOF} \\
	1 &\textrm{ otherwise} \\
\end{cases}$

MNSP bid cost:
\begin{equation}
MNSPCost =\sum\limits_{(i,j,k) \in C} p_{ijk} q_{ijk}
\end{equation}

\subsubsection{Regions}
Dispatched generation at end of dispatch interval:
\begin{equation}
	DispatchedGeneration_{r} = \sum\limits_{i,j \in O^{ENOF}_{r}} TraderTotalOffer_{ij} \quad\forall r \in R
\end{equation}

Dispatched load at end of dispatch interval:
\begin{equation}
DispatchedLoad_{r} = \sum\limits_{i,j \in O^{LDOF}_{r}} TraderTotalOffer_{ij} \quad\forall r \in R
\end{equation}


Dispatched load at start of dispatch interval:
\begin{equation}
InitialScheduledLoad_{r} = \sum\limits_{i,j \in O^{LDOF}_{r} \setminus O^{semi-dispatch}_{r}} TraderInitialMW_{ij} \quad\forall r \in R
\end{equation}

Loss allocated to region at start of dispatch interval:
\begin{equation}
	RegionInitialAllocatedLoss_{r} = \sum\limits_{i \in Interconnectors} InitialLoss_{i} LossShareFactor_{ri} + \sum\limits_{i \in MNSPs} InitialLoss_{i} LossFactor_{ri}
\end{equation}

Loss allocated to region at end of dispatch interval:
\begin{equation}
RegionAllocatedLoss_{r} = \sum\limits_{i \in Interconnectors} Loss_{i} LossShareFactor_{ri} + \sum\limits_{i \in MNSPs} Loss_{i} MNSPLossFactor_{ri}
\end{equation}

where:

$LossShareFactor_{ri}=
\begin{cases}
LossShare_{i} &\textrm{ if $r$ is $i$'s `from' region} \\
1 - LossShare_{i} &\textrm{ if $r$ is $i$'s `to' region} \\
0 &\textrm{ otherwise} \\
\end{cases}$

and 

$MNSPLossFactor_{ri}=
\begin{cases}
1 &\textrm{ if $r$ is $i$'s `from' region and $InitialMW_{i} \geq 0$} \\
0 &\textrm{ otherwise} \\
\end{cases}$

MSNP initial allocated loss:

% if initial flow >= 0 & from region
% (from_lf_export - 1) * (initial_mw + (mnsp_loss_share * loss))

% if initial flow >= 0 & to region
% (to_lf_import - 1) * (initial_mw - ((1 - mnsp_loss_share) * loss)) * -1

% if initial flow < 0 & from region
% (from_lf_import - 1) * (initial_mw + (mnsp_loss_share * loss))

% if initial flow < 0 & to region
%(to_lf_export - 1) * (initial_mw - ((1 - mnsp_loss_share) * loss)) * -1


% RegionLossFactor

$RegionLossFactor_{ri} =
\begin{cases}
(FromLFExport_{i} - 1) & \textrm{ if $r$ is $i$'s `from' region and $InitialMW_{i} \geq 0$} \\
(ToLFImport_{i} - 1) &\textrm{ if $r$ is $i$'s `to' region and $InitialMW_{i} \geq 0$}\\
(FromLFImport_{i} - 1) &\textrm{ if $r$ is $i$'s `from' region and $InitialMW_{i} < 0$}\\
(ToLFExport_{i} - 1) &\textrm{ if $r$ is $i$'s `to' region and $InitialMW_{i} < 0$}\\
0 & \textrm{ otherwise}\\
\end{cases}$

$MNSPLossShare_{ri}=
\begin{cases}
MNSPLossFactor_{ri} & \textrm{ if $r$ is $i$'s `from' region} \\
- (1 - MNSPLossFactor_{ri}) &\textrm{ if $r$ is $i$'s `to' region}\\
0 & \textrm{ otherwise}\\
\end{cases}$

$FlowDirectionFactor_{ri}=
\begin{cases}
1 & \textrm{ if $r$ is $i$'s `from' region} \\
- 1 &\textrm{ if $r$ is $i$'s `to' region}\\
0 & \textrm{ otherwise}\\
\end{cases}$

Initial MNSP loss allocated to region:
\begin{equation}
	MNSPInitialLoss_{r} = \sum\limits_{i \in MNSPs} RegionLossFactor_{ri} (InitialMW_{i} + MNSPLossShare_{ri} InitialLoss_{i}) FlowDirectionFactor_{ri}
\end{equation}

MNSP loss allocated to region:
\begin{equation}
MNSPLoss_{r} = \sum\limits_{i \in MNSPs} RegionLossFactor_{ri} (Flow_{i} + MNSPLossShare_{ri} Loss_{i}) FlowDirectionFactor_{ri}
\end{equation}

Region fixed demand:

\begin{equation}
	FixedDemand_{r} = RegionInitialDemand_{r} + RegionADE_{r} + RegionDF_{r} - RegionInitialScheduledLoad_{r} - RegionInitialAllocatedLoss_{r} - RegionInitialMNSPLoss_{r} 
\end{equation}

Region cleared demand:

%        demand = (
%m.E_REGION_FIXED_DEMAND[r]
%+ m.E_REGION_ALLOCATED_LOSS[r]
%+ m.E_REGION_DISPATCHED_LOAD[r]
%+ m.E_REGION_MNSP_LOSS[r]

\begin{equation}
	ClearedDemand_{r} = RegionFixedDemand_{r} + RegionaAllocatedLoss_{r} + RegionDispatchedLoad_{r} + RegionMNSPLoss_{r}
\end{equation}

Interconnector export:

\begin{equation}
	RegionInterconnectorExport_{r} = \sum\limits_{i \in Interconnectors} FlowDirectionFactor_{ri} Flow_{i}
\end{equation}

Net export:

\begin{equation}
	RegionNetExport_{r} = RegionInterconnectorExport_{r} + RegionAllocatedLoss_{r} + RegionMNSPLoss_{r}
\end{equation}

\subsection{Constraints}
\subsubsection{Units}

Trader total offer:
\begin{equation}
	\hat{q} = \sum\limits_{i = 1}^{10} q_{ijk}
\end{equation}

Trader quantity band limit

\begin{equation}
	q_{ijk} \leq \bar{q}_{ijk} + v_{ijk}^{1}
\end{equation}

Total offer constrained by MaxAvail:

\begin{equation}
\hat{q} \leq UIGF_{ij} + v_{ij}^{2} \quad \forall i \in SemiScheduled \cap j \in {ENOF} 
\end{equation}

\begin{equation}
	\hat{q} \leq MaxAvail_{ij} + v_{ij}^{2} \quad \forall i, j \in TraderOffers \setminus  i \in SemiScheduledUnit \cap j \in {ENOF} 
\end{equation}

% return m.V_TRADER_TOTAL_OFFER[i, j] - initial_mw <= (ramp_limit / 12) + m.V_CV_TRADER_RAMP_UP[i]

Trader ramp-up constraint:
\begin{equation}
\hat{q}_{ij} - TraderInitialMW_{i} \leq (OfferRampUpRate_{ij} / 12) + v^{6}_{ij} \quad \forall i,j \in TraderEnergyOffers
\end{equation}

% return m.V_TRADER_TOTAL_OFFER[i, j] - initial_mw + m.V_CV_TRADER_RAMP_DOWN[i] >= - (ramp_limit / 12)

Trader ramp-down constraint:
\begin{equation}
\hat{q}_{ij} - TraderInitialMW_{i} + v^{7}_{ij} \geq - (OfferRampDownRate_{ij} / 12) \quad \forall i,j \in TraderEnergyOffers
\end{equation}

MNSP total offer:
\begin{equation}
\hat{q}^{m}_{ij} = \sum\limits_{i = 1}^{10} q^{m}_{ijk}
\end{equation}

MNSP band offer:
\begin{equation}
q^{m}_{ijk} \leq \bar{q}^{m}_{ijk} + v_{ijk}^{3} \quad \forall i,j \in MNSPOffers
\end{equation}

MNSP constrained by MaxAvail:
\begin{equation}
\hat{q}^{m}_{ij} \leq MaxAvail_{ij} + v_{ij}^{4} \quad \forall i,j \in MNSPOffers 
\end{equation}

\subsubsection{Generic constraints}
\begin{equation}
	f_{i}(\bm{a}, \bm{b}, \bm{c}) \leq RHS_{i} \quad \forall i \in LEQConstraints
\end{equation}

\begin{equation}
	g_{i}(\bm{a}, \bm{b}, \bm{c}) = RHS_{i} \quad \forall i \in EQConstraints
\end{equation}

\begin{equation}
	h_{i}(\bm{a}, \bm{b}, \bm{c}) \geq RHS_{i} \quad \forall i \in GEQConstraints
\end{equation}

Power balance constraint:
%        return (m.E_REGION_DISPATCHED_GENERATION[r]
%== m.E_REGION_FIXED_DEMAND[r]
%+ m.E_REGION_DISPATCHED_LOAD[r]
%+ m.E_REGION_NET_EXPORT[r])

\begin{equation}
	RegionDispatchGeneration_{r} = RegionFixedDemand_{r} + RegionDispatchedLoad_{r} + RegionNetExport_{r} \quad \forall r \in Regions
\end{equation}

\subsubsection{Interconnector}
Forward flow:
% return m.V_GC_INTERCONNECTOR[i] <= m.P_INTERCONNECTOR_UPPER_LIMIT[i] + m.V_CV_INTERCONNECTOR_FORWARD[i]
\begin{equation}
	b_{i} \leq \overline{B}_{i} + v^{5}_{i} \quad \forall i \in Interconnectors
\end{equation}

Reverse flow:
\begin{equation}
b_{i} + v^{6}_{i} \geq - \overline{B}_{i} \quad \forall i \in Interconnectors
\end{equation}


\subsubsection{FCAS}
% # Only consider generators
%if m.P_TRADER_TYPE[i] != 'GENERATOR':
%return pyo.Constraint.Skip
%
%# Only consider raise regulation FCAS
%if j != 'R5RE':
%return pyo.Constraint.Skip
%
%# Raise regulation FCAS is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%# SCADA ramp rate must be greater than 0
%elif m.P_TRADER_SCADA_RAMP_UP_RATE[i] <= 0:
%return pyo.Constraint.Skip
%
%# Must have an energy offer
%elif (i, 'ENOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%else:
%return (m.V_TRADER_TOTAL_OFFER[i, 'ENOF'] + m.V_TRADER_TOTAL_OFFER[i, 'R5RE']
%<= m.P_TRADER_INITIAL_MW[i] + (m.P_TRADER_SCADA_RAMP_UP_RATE[i] / 12)
%+ m.V_CV_TRADER_FCAS_JOINT_RAMPING_UP[i, j])

Generator joint ramping-up constraint:
\begin{equation}
	\hat{q}_{i,ENOF} + \hat{q}_{i,R5RE}  \leq TraderInitialMW_{i} + (SCADARampUpRate_{i} / 12) + v^{8}_{ij} \quad \forall i,j \in FCASR5REOffers \cap FCASAvailableOffers \cap SCADARampUpRateDefined \cap EnergyOfferDefined \cap GeneratorOffers
\end{equation}

%        # Only consider generators
%if m.P_TRADER_TYPE[i] != 'GENERATOR':
%return pyo.Constraint.Skip
%
%# Only consider raise regulation FCAS
%if j != 'L5RE':
%return pyo.Constraint.Skip
%
%# Raise regulation FCAS is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%# SCADA ramp rate must be greater than 0
%elif m.P_TRADER_SCADA_RAMP_DOWN_RATE[i] <= 0:
%return pyo.Constraint.Skip
%
%# Must have an energy offer
%elif (i, 'ENOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%else:
%return (m.V_TRADER_TOTAL_OFFER[i, 'ENOF'] - m.V_TRADER_TOTAL_OFFER[i, 'L5RE']
%+ m.V_CV_TRADER_FCAS_JOINT_RAMPING_DOWN[i, j]
%>= m.P_TRADER_INITIAL_MW[i] - (m.P_TRADER_SCADA_RAMP_DOWN_RATE[i] / 12))

\begin{equation}
\hat{q}_{i,ENOF} - \hat{q}_{i,L5RE} + v^{9}_{ij} \geq TraderInitialMW_{i} - (SCADARampDownRate_{i} / 12)  \quad \forall i,j \in FCASR5REOffers \cap FCASAvailableOffers \cap SCADARampUpRateDefined \cap EnergyOfferDefined \cap GeneratorOffers
\end{equation}

%        # Only consider generators
%if m.P_TRADER_TYPE[i] != 'GENERATOR':
%return pyo.Constraint.Skip
%
%# Only consider contingency FCAS
%if j not in ['R6SE', 'R60S', 'R5MI', 'L6SE', 'L60S', 'L5MI']:
%return pyo.Constraint.Skip
%
%# Raise regulation FCAS is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%# Must have an energy offer
%elif (i, 'ENOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%elif (i, 'R5RE') in m.S_TRADER_OFFERS:
%usc = utils.fcas.get_upper_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'ENOF'] + (usc * m.V_TRADER_TOTAL_OFFER[i, j])
%+ m.V_TRADER_TOTAL_OFFER[i, 'R5RE']
%<= m.P_TRADER_FCAS_ENABLEMENT_MAX[i, j] + m.V_CV_TRADER_FCAS_JOINT_CAPACITY_RHS[i, j])
%
%else:
%usc = utils.fcas.get_upper_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'ENOF'] + (usc * m.V_TRADER_TOTAL_OFFER[i, j])
%<= m.P_TRADER_FCAS_ENABLEMENT_MAX[i, j] + m.V_CV_TRADER_FCAS_JOINT_CAPACITY_RHS[i, j])
%
%# Joint capacity constraint - generator
%m.C_FCAS_GENERATOR_CONTINGENCY_RHS = pyo.Constraint(m.S_TRADER_OFFERS, rule=generator_joint_capacity_rhs_rule)
Generator joint  capacity constraint (RHS):

\begin{equation}
\hat{q}_{i,ENOF} + UpperSlopeCoefficient_{ij} \hat{q}_{ij} + \hat{q}_{i,R5RE} \leq EffectiveEnablementMax_{ij} + v^{10}_{ij} \quad i,j \in GeneratorOffers \cap ContingencyFCASOffers \cap HasCorrespondingEnergyOffer \cap FCASAvailable \cap HasR5REOffer
\end{equation}

\begin{equation}
\hat{q}_{i,ENOF} + UpperSlopeCoefficient_{ij} \hat{q}_{ij} \leq EffectiveEnablementMax_{ij} + v^{10}_{ij} \quad i,j \in GeneratorOffers \cap ContingencyFCASOffers \cap HasCorrespondingEnergyOffer \cap FCASAvailable \cap HasR5REOffer
\end{equation}

%       # Only consider generators
%if m.P_TRADER_TYPE[i] != 'GENERATOR':
%return pyo.Constraint.Skip
%
%# Only consider contingency FCAS
%if j not in ['R6SE', 'R60S', 'R5MI', 'L6SE', 'L60S', 'L5MI']:
%return pyo.Constraint.Skip
%
%# Raise regulation FCAS is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%# Must have an energy offer
%elif (i, 'ENOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%elif (i, 'L5RE') in m.S_TRADER_OFFERS:
%lsc = utils.fcas.get_lower_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'ENOF'] - (lsc * m.V_TRADER_TOTAL_OFFER[i, j])
%- m.V_TRADER_TOTAL_OFFER[i, 'L5RE'] + m.V_CV_TRADER_FCAS_JOINT_CAPACITY_LHS[i, j]
%>= m.P_TRADER_FCAS_ENABLEMENT_MIN[i, j])
%
%else:
%lsc = utils.fcas.get_lower_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'ENOF'] - (lsc * m.V_TRADER_TOTAL_OFFER[i, j])
%+ m.V_CV_TRADER_FCAS_JOINT_CAPACITY_LHS[i, j]
%>= m.P_TRADER_FCAS_ENABLEMENT_MIN[i, j])

Generator joint  capacity constraint (LHS):

\begin{equation}
\hat{q}_{i,ENOF} - LowerSlopeCoefficient_{ij} \hat{q}_{ij} - \hat{q}_{i,L5RE} + v^{11}_{ij} \geq EffectiveEnablementMin_{ij}  \quad i,j \in GeneratorOffers \cap ContingencyFCASOffers \cap HasCorrespondingEnergyOffer \cap FCASAvailable \cap HasL5REOffer
\end{equation}

\begin{equation}
\hat{q}_{i,ENOF} - LowerSlopeCoefficient_{ij} \hat{q}_{ij} + v^{11}_{ij} \geq EffectiveEnablementMin_{ij}  \quad i,j \in GeneratorOffers \cap ContingencyFCASOffers \cap HasCorrespondingEnergyOffer \cap FCASAvailable \cap NoL5REOffer
\end{equation}

%        # Only consider generators
%if m.P_TRADER_TYPE[i] != 'GENERATOR':
%return pyo.Constraint.Skip
%
%# Only consider regulation raise service
%if j not in ['R5RE', 'L5RE']:
%return pyo.Constraint.Skip
%
%# Trader must have an energy offer
%elif (i, 'ENOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%# Regulating FCAS must be available
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%else:
%usc = utils.fcas.get_upper_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'ENOF'] + (usc * m.V_TRADER_TOTAL_OFFER[i, j])
%<= m.E_TRADER_FCAS_EFFECTIVE_ENABLEMENT_MAX[i, j] + m.V_CV_TRADER_FCAS_ENERGY_REGULATING_RHS[i, j])

Joint energy and regulating FCAS constraint (RHS):
\begin{equation}
\hat{q}_{i,ENOF} + UpperSlopeCoefficient_{ij} \hat{q}_{ij} \leq EffectiveEnablementMax_{ij} + v_{ij}^{12} \quad \forall i,j \in GeneratorOffers \cap RegulatingFCASOffers \cap HasEnergyOffer \cap FCASAvailable
\end{equation}

%        # Only consider generators
%if m.P_TRADER_TYPE[i] != 'GENERATOR':
%return pyo.Constraint.Skip
%
%# Only consider regulation raise service
%if j not in ['R5RE', 'L5RE']:
%return pyo.Constraint.Skip
%
%# Trader must have an energy offer
%elif (i, 'ENOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%# Regulating FCAS must be available
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%else:
%lsc = utils.fcas.get_lower_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'ENOF'] - (lsc * m.V_TRADER_TOTAL_OFFER[i, j])
%+ m.V_CV_TRADER_FCAS_ENERGY_REGULATING_LHS[i, j]
%>= m.E_TRADER_FCAS_EFFECTIVE_ENABLEMENT_MIN[i, j])

Joint energy and regulating FCAS constraint (LHS):
\begin{equation}
\hat{q}_{i,ENOF} - LowerSlopeCoefficient_{ij} \hat{q}_{ij} + v_{ij}^{13} \geq EffectiveEnablementMin_{ij}  \quad \forall i,j \in GeneratorOffers \cap RegulatingFCASOffers \cap HasEnergyOffer \cap FCASAvailable
\end{equation}

%        # Only consider generators
%if m.P_TRADER_TYPE[i] != 'GENERATOR':
%return pyo.Constraint.Skip
%
%# Only consider FCAS offers
%if j not in ['R5RE', 'R6SE', 'R60S', 'R5MI', 'L5RE', 'L6SE', 'L60S', 'L5MI']:
%return pyo.Constraint.Skip
%
%# Fix to zero if FCAS service is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return m.V_TRADER_TOTAL_OFFER[i, j] == 0 + m.V_CV_TRADER_FCAS_MAX_AVAILABLE[i, j]
%
%elif j == 'R5RE':
%effective_max_avail = min([(m.P_TRADER_SCADA_RAMP_UP_RATE[i] / 12), m.P_TRADER_FCAS_MAX_AVAILABLE[i, j]])
%return m.V_TRADER_TOTAL_OFFER[i, j] <= effective_max_avail + m.V_CV_TRADER_FCAS_MAX_AVAILABLE[i, j]
%
%elif j == 'L5RE':
%effective_max_avail = min([(m.P_TRADER_SCADA_RAMP_DOWN_RATE[i] / 12), m.P_TRADER_FCAS_MAX_AVAILABLE[i, j]])
%return m.V_TRADER_TOTAL_OFFER[i, j] <= effective_max_avail + m.V_CV_TRADER_FCAS_MAX_AVAILABLE[i, j]
%
%else:
%return (m.V_TRADER_TOTAL_OFFER[i, j]
%<= m.P_TRADER_FCAS_MAX_AVAILABLE[i, j] + m.V_CV_TRADER_FCAS_MAX_AVAILABLE[i, j])

Generator max FCAS available:
\begin{equation}
	\hat{q}_{ij} \leq EffectiveMaxAvailable_{ij} + v_{ij}^{14} \quad \forall i,j \in GeneratorOffers \cap FCASOffers
\end{equation}

%        # Only consider loads
%if m.P_TRADER_TYPE[i] not in ['LOAD', 'NORMALLY_ON_LOAD']:
%return pyo.Constraint.Skip
%
%# Only consider raise regulation FCAS
%if j != 'R5RE':
%return pyo.Constraint.Skip
%
%# Raise regulation FCAS is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%# SCADA ramp rate must be greater than 0
%elif m.P_TRADER_SCADA_RAMP_DOWN_RATE[i] <= 0:
%return pyo.Constraint.Skip
%
%# Must have an energy offer
%elif (i, 'LDOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%else:
%return (m.V_TRADER_TOTAL_OFFER[i, 'LDOF'] - m.V_TRADER_TOTAL_OFFER[i, 'R5RE']
%+ m.V_CV_TRADER_FCAS_JOINT_RAMPING_UP[i, j]
%>= m.P_TRADER_INITIAL_MW[i] - (m.P_TRADER_SCADA_RAMP_DOWN_RATE[i] / 12))

Load joint ramping raise regulation:
\begin{equation}
	\hat{q}_{ij} - \hat{q}_{i,R5RE} + v_{ij}^{15} \geq TraderInitialMW_{ij} - (TraderSCADARampDownRate_{i} / 12) \quad \forall i,j \in LoadOffers \cap R5REOffers \cap FCASAvailable \cap HasSCADARampDownRate \cap HasEnergyOffer
\end{equation}

%        # Only consider loads
%if m.P_TRADER_TYPE[i] not in ['LOAD', 'NORMALLY_ON_LOAD']:
%return pyo.Constraint.Skip
%
%# Only consider raise regulation FCAS
%if j != 'L5RE':
%return pyo.Constraint.Skip
%
%# Lower regulation FCAS is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%# SCADA ramp rate must be greater than 0
%elif m.P_TRADER_SCADA_RAMP_UP_RATE[i] <= 0:
%return pyo.Constraint.Skip
%
%# Must have an energy offer
%elif (i, 'LDOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%else:
%return (m.V_TRADER_TOTAL_OFFER[i, 'LDOF'] + m.V_TRADER_TOTAL_OFFER[i, 'L5RE']
%<= m.P_TRADER_INITIAL_MW[i] + (m.P_TRADER_SCADA_RAMP_UP_RATE[i] / 12)
%+ m.V_CV_TRADER_FCAS_JOINT_RAMPING_DOWN[i, j])

Load joint ramping lower regulation:
\begin{equation}
\hat{q}_{i,LDOF} + \hat{q}_{i,L5RE} \leq TraderInitialMW_{i} + (TraderSCADARampUpRate_{i} / 12) + v_{ij}^{15} \quad \forall i,j \in LoadOffers \cap L5REOffers \cap FCASAvailable \cap HasSCADARampUpRate \cap HasEnergyOffer
\end{equation}

%        # Only consider loads
%if m.P_TRADER_TYPE[i] not in ['LOAD', 'NORMALLY_ON_LOAD']:
%return pyo.Constraint.Skip
%
%# Only consider contingency FCAS
%if j not in ['R6SE', 'R60S', 'R5MI', 'L6SE', 'L60S', 'L5MI']:
%return pyo.Constraint.Skip
%
%# Raise regulation FCAS is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%# Must have an energy offer
%elif (i, 'LDOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%elif (i, 'L5RE') in m.S_TRADER_OFFERS:
%usc = utils.fcas.get_upper_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'LDOF'] + (usc * m.V_TRADER_TOTAL_OFFER[i, j])
%+ m.V_TRADER_TOTAL_OFFER[i, 'L5RE']
%<= m.P_TRADER_FCAS_ENABLEMENT_MAX[i, j] + m.V_CV_TRADER_FCAS_JOINT_CAPACITY_RHS[i, j])
%
%else:
%usc = utils.fcas.get_upper_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'LDOF'] + (usc * m.V_TRADER_TOTAL_OFFER[i, j])
%<= m.P_TRADER_FCAS_ENABLEMENT_MAX[i, j] + m.V_CV_TRADER_FCAS_JOINT_CAPACITY_RHS[i, j])

Load joint capacity (RHS):
\begin{equation}
\hat{q}_{i,LDOF} + UpperSlopeCoefficient_{ij} \hat{q}_{ij} + \hat{q}_{i,L5RE} \leq EffectiveEnablementMax_{ij} + v_{ij}^{16} \quad \forall i,j \in LoadOffers \cap ContingencyFCASOffers \cap FCASAvailable \cap HasEnergyOffer \cap HasL5REOffer
\end{equation}

\begin{equation}
\hat{q}_{i,LDOF} + UpperSlopeCoefficient_{ij} \hat{q}_{ij} \leq EffectiveEnablementMax_{ij} + v_{ij}^{16} \quad \forall i,j \in LoadOffers \cap ContingencyFCASOffers \cap FCASAvailable \cap HasEnergyOffer \cap NoL5REOffer
\end{equation}

%        # Only consider loads
%if m.P_TRADER_TYPE[i] not in ['LOAD', 'NORMALLY_ON_LOAD']:
%return pyo.Constraint.Skip
%
%# Only consider contingency FCAS
%if j not in ['R6SE', 'R60S', 'R5MI', 'L6SE', 'L60S', 'L5MI']:
%return pyo.Constraint.Skip
%
%# Raise regulation FCAS is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%# Must have an energy offer
%elif (i, 'LDOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%elif (i, 'R5RE') in m.S_TRADER_OFFERS:
%lsc = utils.fcas.get_lower_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'LDOF'] - (lsc * m.V_TRADER_TOTAL_OFFER[i, j])
%- m.V_TRADER_TOTAL_OFFER[i, 'R5RE'] + m.V_CV_TRADER_FCAS_JOINT_CAPACITY_LHS[i, j]
%>= m.P_TRADER_FCAS_ENABLEMENT_MIN[i, j])
%
%else:
%lsc = utils.fcas.get_lower_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'LDOF'] - (lsc * m.V_TRADER_TOTAL_OFFER[i, j])
%+ m.V_CV_TRADER_FCAS_JOINT_CAPACITY_LHS[i, j]
%>= m.P_TRADER_FCAS_ENABLEMENT_MIN[i, j])

Load joint capacity (LHS):
\begin{equation}
\hat{q}_{i,LDOF} - LowerSlopeCoefficient_{ij} \hat{q}_{ij} - \hat{q}_{i,R5RE} + v_{ij}^{17} \geq EnablementMin_{ij} \quad \forall i,j \in LoadOffers \cap ContingencyFCASOffers \cap FCASAvailable \cap HasEnergyOffer \cap HasR5REOffer
\end{equation}

\begin{equation}
\hat{q}_{i,LDOF} - LowerSlopeCoefficient_{ij} \hat{q}_{ij} + v_{ij}^{17} \geq EnablementMin_{ij} \quad \forall i,j \in LoadOffers \cap ContingencyFCASOffers \cap FCASAvailable \cap HasEnergyOffer \cap NoR5REOffer
\end{equation}

%        # Only consider loads
%if m.P_TRADER_TYPE[i] not in ['LOAD', 'NORMALLY_ON_LOAD']:
%return pyo.Constraint.Skip
%
%# Only consider regulation raise service
%if j not in ['R5RE', 'L5RE']:
%return pyo.Constraint.Skip
%
%# Trader must have an energy offer
%elif (i, 'LDOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%# Regulating FCAS must be available
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%else:
%usc = utils.fcas.get_upper_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'LDOF'] + (usc * m.V_TRADER_TOTAL_OFFER[i, j])
%<= m.E_TRADER_FCAS_EFFECTIVE_ENABLEMENT_MAX[i, j] + m.V_CV_TRADER_FCAS_ENERGY_REGULATING_RHS[i, j])

Load joint energy regulating FCAS constraint (RHS):
\begin{equation}
	\hat{q}_{i,LDOF} + UpperSlopeCoefficient_{ij} \hat{q}_{ij} \leq EffectiveEnablementMax_{ij} + v_{ij}^{18} \quad \forall i,j \in LoadOffers \cap RegulatingFCASOffers \cap HasEnergyOffer \cap FCASAvailable
\end{equation}

%        # Only consider loads
%if m.P_TRADER_TYPE[i] not in ['LOAD', 'NORMALLY_ON_LOAD']:
%return pyo.Constraint.Skip
%
%# Only consider regulation raise service
%if j not in ['R5RE', 'L5RE']:
%return pyo.Constraint.Skip
%
%# Trader must have an energy offer
%elif (i, 'LDOF') not in m.S_TRADER_OFFERS:
%return pyo.Constraint.Skip
%
%# Regulating FCAS must be available
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return pyo.Constraint.Skip
%
%else:
%lsc = utils.fcas.get_lower_slope_coefficient(data, i, j)
%return (m.V_TRADER_TOTAL_OFFER[i, 'LDOF'] - (lsc * m.V_TRADER_TOTAL_OFFER[i, j])
%+ m.V_CV_TRADER_FCAS_ENERGY_REGULATING_LHS[i, j]
%>= m.E_TRADER_FCAS_EFFECTIVE_ENABLEMENT_MIN[i, j])

Load joint energy regulating FCAS constraint (LHS):
\begin{equation}
\hat{q}_{i,LDOF} - LowerSlopeCoefficient_{ij} \hat{q}_{ij} + v_{ij}^{19} \geq EffectiveEnablementMin_{ij}  \quad \forall i,j \in LoadOffers \cap RegulatingFCASOffers \cap HasEnergyOffer \cap FCASAvailable
\end{equation}

%        # Only consider loads
%if m.P_TRADER_TYPE[i] not in ['LOAD', 'NORMALLY_ON_LOAD']:
%return pyo.Constraint.Skip
%
%# Only consider FCAS offers
%if j not in ['R5RE', 'R6SE', 'R60S', 'R5MI', 'L5RE', 'L6SE', 'L60S', 'L5MI']:
%return pyo.Constraint.Skip
%
%# Fix to zero if FCAS service is unavailable
%elif not m.P_TRADER_FCAS_AVAILABILITY_STATUS[i, j]:
%return m.V_TRADER_TOTAL_OFFER[i, j] == 0 + m.V_CV_TRADER_FCAS_MAX_AVAILABLE[i, j]
%
%elif j == 'R5RE':
%effective_max_avail = min([(m.P_TRADER_SCADA_RAMP_DOWN_RATE[i] / 12), m.P_TRADER_FCAS_MAX_AVAILABLE[i, j]])
%return m.V_TRADER_TOTAL_OFFER[i, j] <= effective_max_avail + m.V_CV_TRADER_FCAS_MAX_AVAILABLE[i, j]
%
%elif j == 'L5RE':
%effective_max_avail = min([(m.P_TRADER_SCADA_RAMP_UP_RATE[i] / 12), m.P_TRADER_FCAS_MAX_AVAILABLE[i, j]])
%return m.V_TRADER_TOTAL_OFFER[i, j] <= effective_max_avail + m.V_CV_TRADER_FCAS_MAX_AVAILABLE[i, j]
%
%else:
%return (m.V_TRADER_TOTAL_OFFER[i, j]
%<= m.P_TRADER_FCAS_MAX_AVAILABLE[i, j] + m.V_CV_TRADER_FCAS_MAX_AVAILABLE[i, j])
%
%# Effective max available FCAS
%m.C_FCAS_LOAD_MAX_AVAILABLE = pyo.Constraint(m.S_TRADER_OFFERS, rule=load_fcas_max_available_rule)

Load max FCAS available:
\begin{equation}
	\hat{q}_{ij} \leq EffectiveMaxAvail_{ij} + v_{ij}^{20} \quad \forall i,j \in LoadOffers \cap FCASOffers
\end{equation}

\subsubsection{Loss model}

%        return (m.V_LOSS[i]
%== sum(m.P_INTERCONNECTOR_LOSS_MODEL_BREAKPOINT_Y[i, k] * m.V_LOSS_LAMBDA[i, k]
%for j, k in m.S_INTERCONNECTOR_LOSS_MODEL_BREAKPOINTS if j == i)
%)
Approximated loss:
\begin{equation}
	Loss_{i} = \sum\limits_{k} BreakPointY_{ik} \lambda_{ik} \quad \forall i
\end{equation}

%        return (m.V_GC_INTERCONNECTOR[i] == sum(m.P_INTERCONNECTOR_LOSS_MODEL_BREAKPOINT_X[i, k] * m.V_LOSS_LAMBDA[i, k]
%for j, k in m.S_INTERCONNECTOR_LOSS_MODEL_BREAKPOINTS if j == i))

SOS2 condition 1:
\begin{equation}
	Flow_{i} = \sum\limits_{k} BreakPointX_{ik} \lambda_{ik} \quad \forall i
\end{equation}

%        return sum(m.V_LOSS_LAMBDA[i, k] for j, k in m.S_INTERCONNECTOR_LOSS_MODEL_BREAKPOINTS if j == i) == 1
SOS2 condition 2:
\begin{equation}
	\sum\limits_{k} \lambda_{ik} = 1 \quad \forall i
\end{equation}

%        return sum(m.V_LOSS_Y[i, k] for j, k in m.S_INTERCONNECTOR_LOSS_MODEL_INTERVALS if j == i) == 1
SOS2 condition 3:
\begin{equation}
	\sum\limits_{k} LossY_{ik} = 1 \quad \forall i
\end{equation}


%        # Last interconnector breakpoint index
%end = max(segment_id for interconnector_id, segment_id in m.S_INTERCONNECTOR_LOSS_MODEL_BREAKPOINTS
%if interconnector_id == i)

%if (j >= 2) and (j <= end - 1):
%return (sum(m.V_LOSS_Y[i, z] for z in range(j + 1, end))
%<= sum(m.V_LOSS_LAMBDA[i, z] for z in range(j + 1, end + 1)))
%else:
%return pyo.Constraint.Skip
SOS2 condition 4:
\begin{equation}
	\sum\limits_{z=l+1}^{k-1} LossY_{iz} \leq \sum\limits_{z=l+1}^{k} \lambda_{iz} \quad \forall l=2,\ldots,k-1 \quad \forall i
\end{equation}

%        # Last interconnector breakpoint index
%end = max(segment_id for interconnector_id, segment_id in m.S_INTERCONNECTOR_LOSS_MODEL_BREAKPOINTS
%if interconnector_id == i)
%
%# TODO: not sure if j >= 2 or j >= 1 because S_INTERCONNECTOR_LOSS_MODEL_BREAKPOINTS starts from 0. Similarly,
%# not sure if (j <= end - 1) is correct
%if (j >= 2) and (j <= end - 1):
%return (sum(m.V_LOSS_LAMBDA[i, z] for z in range(j + 1, end + 1))
%<= sum(m.V_LOSS_Y[i, z] for z in range(j, end)))
%else:
%return pyo.Constraint.Skip

SOS2 condition 5:
\begin{equation}
\sum\limits_{z=l+1}^{k} \lambda_{iz} \leq \sum\limits_{z=l}^{k-1} LossY_{iz} \quad \forall l=2,\ldots,k-1 \quad \forall i
\end{equation}

%SOS2 condition 6:
%        # Last interconnector breakpoint index
%end = max(segment_id for interconnector_id, segment_id in m.S_INTERCONNECTOR_LOSS_MODEL_BREAKPOINTS
%if interconnector_id == i)
%
%if j == 1:
%return m.V_LOSS_LAMBDA[i, j] <= m.V_LOSS_Y[i, j]
%elif j == end:
%return m.V_LOSS_LAMBDA[i, j] <= m.V_LOSS_Y[i, j - 1]
%else:
%return pyo.Constraint.Skip

SOS2 condition 6:
\begin{equation}
	\lambda_{i,1} \leq LossY_{i,1}
\end{equation}

SOS2 condition 7:
\begin{equation}
\lambda_{i,k} \leq LossY_{i,k-1}
\end{equation}

\subsubsection{Fast-start inflexibility constraints}
%        if m.P_TRADER_TYPE[i] == 'GENERATOR':
%energy_offer = 'ENOF'
%elif m.P_TRADER_TYPE[i] in ['LOAD', 'NORMALLY_ON_LOAD']:
%energy_offer = 'LDOF'
%else:
%raise Exception('Unexpected energy offer:', i)
%
%# Unit is synchronising - output = 0
%if (m.P_TRADER_CURRENT_MODE[i] == '0') or (m.P_TRADER_CURRENT_MODE[i] == '1'):
%return (m.V_TRADER_TOTAL_OFFER[i, energy_offer] + m.V_CV_TRADER_INFLEXIBILITY_PROFILE_LHS[i]
%== 0 + m.V_CV_TRADER_INFLEXIBILITY_PROFILE_RHS[i])
%
%# Unit ramping to min loading - energy output fixed to profile
%elif m.P_TRADER_CURRENT_MODE[i] == '2':
%slope = m.P_TRADER_MIN_LOADING_MW[i] / m.P_TRADER_T2
%startup_profile = slope * m.P_TRADER_CURRENT_MODE_TIME[i]
%return (m.V_TRADER_TOTAL_OFFER[i, energy_offer] + m.V_CV_TRADER_INFLEXIBILITY_PROFILE_LHS[i]
%== startup_profile + m.V_CV_TRADER_INFLEXIBILITY_PROFILE_RHS[i])
%
%# Output lower bounded by MinLoadingMW
%elif m.P_TRADER_CURRENT_MODE[i] == '3':
%return (m.V_TRADER_TOTAL_OFFER[i, energy_offer] + m.V_CV_TRADER_INFLEXIBILITY_PROFILE[i]
%>= m.P_TRADER_MIN_LOADING_MW[i])
%
%# Output still lower bounded by inflexibility profile
%elif (m.P_TRADER_CURRENT_MODE[i] == '4') and (m.P_TRADER_CURRENT_MODE_TIME[i] < m.P_TRADER_T4[i]):
%slope = - m.P_TRADER_MIN_LOADING_MW[i] / m.P_TRADER_T4[i]
%max_output = (slope * m.P_TRADER_CURRENT_MODE_TIME[i]) + m.P_TRADER_MIN_LOADING_MW[i]
%
%return m.V_TRADER_TOTAL_OFFER[i, energy_offer] + m.V_CV_TRADER_INFLEXIBILITY_PROFILE[i] >= max_output
%
%# Unit operating normally - output not constrained by inflexibility profile
%else:
%return pyo.Constraint.Skip

Output fixed to 0 when unit unavailable / synchronising:
\begin{equation}
	\hat{q}_{i,EnergyOffer} + v_{ij}^{21} = 0 + v_{ij}^{22} \quad \forall i,j \in EnergyOffers \cap TraderCurrentMode0 \cup TraderCurrentMode1
\end{equation}

Output fixed to startup profile when ramping to min-loading:
\begin{equation}
\hat{q}_{i,EnergyOffer} + v_{ij}^{23} = StartupProfile + v_{ij}^{24} \quad \forall i,j \in EnergyOffers \cap TraderCurrentMode2
\end{equation}

Output lower bound is min loading when in mode 3:
\begin{equation}
\hat{q}_{i,EnergyOffer} + v_{ij}^{24} \geq MinLoading_{i} \quad \forall i,j \in EnergyOffers \cap TraderCurrentMode3
\end{equation}

Output lower bound is inflexibility profile when in mode 4:
\begin{equation}
\hat{q}_{i,EnergyOffer} + v_{ij}^{25} \geq InflexibilityProfile_{i} \quad \forall i,j \in EnergyOffers \cap TraderCurrentMode4 \cap InModel4
\end{equation}

\subsubsection{Tie-breaking constraints}
%        if (m.P_TRADER_QUANTITY_BAND[i, j, k] == 0) or (m.P_TRADER_QUANTITY_BAND[q, r, s] == 0):
%return pyo.Constraint.Skip
%
%return ((m.V_TRADER_OFFER[i, j, k] / m.P_TRADER_QUANTITY_BAND[i, j, k])
%- (m.V_TRADER_OFFER[q, r, s] / m.P_TRADER_QUANTITY_BAND[q, r, s])
%== m.V_TRADER_SLACK_1[i, j, k, q, r, s] - m.V_TRADER_SLACK_2[i, j, k, q, r, s])

\begin{equation}
	(q_{ijk} / \overline{q}_{ijk}) - (q_{qrs} / \overline{q}_{qrs}) = Slack1_{ijkqrs} - Slack2_{ijkqrs} \quad \forall i,j,k,q,r,s \in PriceTied
\end{equation}

\begin{equation}
TieBreakCost = \sum\limits_{i,j,k,q,r,s \in PriceTied}	TieBreakPrice(Slack1_{ijkqrs} + Slack2_{ijkqrs})
\end{equation}

\subsection{Objective Function}
\begin{equation}
	\minimise \quad UnitCost + MNSPCost + ConstraintViolationPenalty + TieBreakCost
\end{equation}


\end{document}